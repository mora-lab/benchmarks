---
title: "Comparison_Metrics_GSA_Tools"
author: "Shaurya Jauhari"
date: "3/13/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Rank calculation | Prioritization | Chipenrich}
ranks <- list()
x <- 1

  for (i in 1:length(broadenrich_results_shredded$GSM2058093$Geneset.ID))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j])
            {
              ranks[[x]]<- i
              x <- x+1
      
            }
        }
    }

for_prioritization <- as.double((ranks[[1]]/length(broadenrich_results_shredded$GSM2058093$Geneset.ID)*100))
print(for_prioritization)
```


```{r Rank calculation | Prioritization | Broadenrich}
## For now, each sample name has to be fed manually in the appropriate location, one in each run.(3 instances)
## Also to be replaced is the disease name after each sample set.(2 instances)
ranks <- list()
x <- 1

  for (i in 1:length(broadenrich_results_shredded$GSM2058093$Geneset.ID))
    {
      for (j in 1:length(prostate_cancer_id_pool)) ## This is the Target Pathway ##
        {
          if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j])
            {
             # cat(sprintf("The %i position in broadenrich_results matches with %i position in prostate_cancer_id_pool", i,j),"\n")
## You can cross check the common elements in two sets.            
##  intersect(broadenrich_results_shredded$GSM2058093$Geneset.ID,prostate_cancer_id_pool)           
              ranks[[x]]<- i
              x <- x+1
      
            }
        }
    }

for_prioritization <- as.double((ranks[[1]]/length(broadenrich_results_shredded$GSM2058093$Geneset.ID)*100))
print(for_prioritization)

## Rounding off the value.
#print(round(prioritization))
## We may recall that the results from the GSA tools are already sorted in terms of statistical significance (p-values). However, the KEGG and GO terms for a disease are just representations and do not follow any particular order. Thus, on comparing the matches in the two categories, the hits that occur in the results from the GSA tools will be the ranks. Our aim is to find if any term in the disease pool lies in the results. The lowest amongst all ranks is the effective rank for that tool.

## For prioritization, we need to calculate the rank in terms of percentage. i.e. (rank/total) *100
## Lower, the better!
```

```{r Rank calculation | Prioritization | Seq2pathway}

ranks <- list()
x <- 1

  for (i in 1:length(seq2pathway_results_shredded$GSM2058093$GOID))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (seq2pathway_results_shredded$GSM2058093$GOID[i] == prostate_cancer_id_pool[j])
            {
              ranks[[x]]<- i
              x <- x+1
      
            }
        }
    }

for_prioritization <- as.double((ranks[[1]]/length(seq2pathway_results_shredded$GSM2058093$GOID)*100))
print(for_prioritization)

```

```{r Rank calculation | Prioritization | Enrichr | Pre-processing}

## Testing if the samples names are consistent between KEGG and GO results.
count <- 0
for (i in 1:length(names(enrichr_go_results_shredded)))
{
  for(j in 1:length(names(enrichr_kegg_results_shredded)))
  {
    if(names(enrichr_go_results_shredded)[i] == names(enrichr_kegg_results_shredded)[j])
    {
      count <- count+1
      sprint(count, "Same name")
    }
  }
}
print (count) ## That is equal to total samples. Cool!

## Refining Enrichr KEGG and GO results | Extracting "hsa*****" and "GO:*****" terms.
library(stringr)

enrichr_go_terms_extracted_results_shredded <- list()
enrichr_go_terms_extracted_results_shredded <- enrichr_go_results_shredded
for (i in 1:length(enrichr_go_results_shredded))
{
   enrichr_go_terms_extracted_results_shredded[[i]]$Term <- str_extract(string = print(eval(parse(text=paste("enrichr_go_results_shredded$",paste(eval(parse(text="names(enrichr_go_results_shredded)[i]")),"$Term", sep = ""), sep = "")))), pattern = "GO:[0-9]+")
}
  
enrichr_kegg_terms_extracted_results_shredded <- list()
enrichr_kegg_terms_extracted_results_shredded <- enrichr_kegg_results_shredded
for (i in 1:length(enrichr_kegg_results_shredded))
{
   enrichr_kegg_terms_extracted_results_shredded[[i]]$Term <- str_extract(string = print(eval(parse(text=paste("enrichr_kegg_results_shredded$",paste(eval(parse(text="names(enrichr_kegg_results_shredded)[i]")),"$Term", sep = ""), sep = "")))), pattern = "hsa[0-9]+")
}

## Combining Enrichr KEGG and GO results

enrichr_results_shredded <- list()
length(enrichr_results_shredded) <- length (enrichr_go_terms_extracted_results_shredded)
names(enrichr_results_shredded) <- names (enrichr_go_terms_extracted_results_shredded)

for (i in 1:length(enrichr_results_shredded))
{
    if(names(enrichr_results_shredded) == names(enrichr_go_terms_extracted_results_shredded) && names(enrichr_results_shredded) == names(enrichr_kegg_terms_extracted_results_shredded))
        {
              enrichr_results_shredded[[i]] <- rbind(enrichr_go_terms_extracted_results_shredded[[i]], enrichr_kegg_terms_extracted_results_shredded[[i]], stringsAsFactors = FALSE)
        }
}

## Sorting on the basis of "P.value"

for (i in 1:length(enrichr_results_shredded))
  {
    enrichr_results_shredded[[i]] <- enrichr_results_shredded[[i]][with(enrichr_results_shredded[[i]], order(enrichr_results_shredded[[i]]$P.value)), ] 
  }

```


```{r Enrichr | Final Calculation}

ranks <- list()
x <- 1

  for (i in 1:length(enrichr_results_shredded$GSM2058093$Term))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (enrichr_results_shredded$GSM2058093$Term[i] == prostate_cancer_id_pool[j])
            {
              ranks[[x]]<- i
              x <- x+1
      
            }
        }
    }

for_prioritization <- as.double((ranks[[1]]/length(enrichr_results_shredded$GSM2058093$Term)*100))
print(for_prioritization)


## Trying to automate
# 
# for (i in 1:length(enrichr_results_shredded))
# {
#   temp[i] <- as.double((ranks[[1]]/length(eval(parse(text=(paste("enrichr_results_shredded$",paste(eval(parse(text="names(enrichr_results_shredded)[i]")),"$Term", sep = ""), sep = "")))))*100))
# }
```


```{r P-Value calculation | Surrogate Sensitivity | Chipenrich}

## We are interested to highlight the first (lowest) p-value of the match between target pathway and the tool outputs. The median of all such p-values for every sample in the benchmark dataset shall be the surrogate sensitivity. Note that the surrogate sensitivity doesn't take into account the p< 0.05 threshold.

p_values <- list()
x <- 1

  for (i in 1:length(broadenrich_results_shredded$GSM2058093$Geneset.ID))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j])
            {
              p_values[[x]]<- broadenrich_results_shredded$GSM2058093$P.value[i]
              x <- x+1
      
            }
        }
    }

for_surrogate_sensitivity <- p_values[[1]]
print(for_surrogate_sensitivity)

```


```{r P-Value calculation | Surrogate Sensitivity | Broadenrich}
p_values <- list()
x <- 1

  for (i in 1:length(broadenrich_results_shredded$GSM2058093$Geneset.ID))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j])
            {
              p_values[[x]]<- broadenrich_results_shredded$GSM2058093$P.value[i]
              x <- x+1
      
            }
        }
    }

for_surrogate_sensitivity <- p_values[[1]]
print(for_surrogate_sensitivity)

```


```{r P-Value calculation | Surrogate Sensitivity | Seq2pathway}

p_values <- list()
x <- 1

  for (i in 1:length(seq2pathway_results_shredded$GSM2058093$GOID))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (seq2pathway_results_shredded$GSM2058093$GOID[i] == prostate_cancer_id_pool[j])
            {
              p_values[[x]]<- seq2pathway_results_shredded$GSM2058093$Fisher_Pvalue[i]
              x <- x+1
      
            }
        }
    }

for_surrogate_sensitivity <- p_values[[1]]
print(for_surrogate_sensitivity)

```
 
 
```{r P-Value calculation | Surrogate Sensitivity | Enrichr}

p_values <- list()
x <- 1

  for (i in 1:length(enrichr_results_shredded$GSM2058093$Term))
    {
      for (j in 1:length(prostate_cancer_id_pool))
        {
          if (enrichr_results_shredded$GSM2058093$Term[i] == prostate_cancer_id_pool[j])
            {
              p_values[[x]]<- enrichr_results_shredded$GSM2058093$P.value[i]
              x <- x+1
      
            }
        }
    }

for_surrogate_sensitivity <- p_values[[1]]
print(for_surrogate_sensitivity)

```

```{r Classical Sensitivity, Specificity, Precision | Broadenrich}

true_positives <- list()
true_negatives_ids <- list()
false_positives1_ids <- list()
false_positives2_ids <- list()
false_positives <- list()
false_negatives <- list()
count1 <- 1
count2 <- 1

## Iterating through the entire length of tool results and id-pool gives the same impression as usign "intersect" and "setdiff" set-operations, thereby achieving the common objective; just for flavor here.

 for (i in 1:length(broadenrich_results_shredded$GSM2058093$Geneset.ID))
     {
       for (j in 1:length(prostate_cancer_id_pool))
         {
           if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j] && broadenrich_results_shredded$GSM2058093$P.value[i] <= 0.05)
             {
               true_positives[[count1]]<- prostate_cancer_id_pool[j]
               count1 <- count1 + 1
           }
           if (broadenrich_results_shredded$GSM2058093$Geneset.ID[i] == prostate_cancer_id_pool[j] && broadenrich_results_shredded$GSM2058093$P.value[i] > 0.05)
             {
               false_negatives[[count2]]<- prostate_cancer_id_pool[j]
               count2 <- count2 + 1
           }
      }
  }


## Tool results' subsets on the basis of statistical significance.
greater_than_0.05 <- broadenrich_results_shredded$GSM2058093[which(broadenrich_results_shredded$GSM2058093$P.value > 0.05),]
less_than_0.05 <- broadenrich_results_shredded$GSM2058093[which(broadenrich_results_shredded$GSM2058093$P.value <= 0.05),]
true_negatives_ids <- setdiff(greater_than_0.05$Geneset.ID, prostate_cancer_id_pool) ## All ids that are there in the tool result with p > 0.05 and absent in the disease pool.

false_positives1_ids <- intersect(prostate_cancer_id_pool,greater_than_0.05$Geneset.ID)   
false_positives2_ids <- setdiff(less_than_0.05$Geneset.ID,prostate_cancer_id_pool)
      
false_positives <- c(false_positives1_ids,false_positives2_ids)        

## Results

cat("True positives:",length(true_positives))
cat("\nTrue negatives:",length(true_negatives_ids))
cat("\nFalse negatives:",length(false_negatives))
cat("\nFalse positives:",length(false_positives))
precision <- length(true_positives)/(length(true_positives)+length(false_positives))
cat("\nPrecision(in percentage):", precision*100)
sensitivity <- length(true_positives)/(length(true_positives)+length(false_negatives))
cat("\nSensitivity(in percentage):", sensitivity*100)
specificity <- length(true_negatives_ids)/(length(true_negatives_ids)+length(false_positives))
cat("\nSpecificity(in percentage):", specificity*100)

```


```{r Classical Sensitivity, Specificity, Precision | Seq2pathway}

true_positives <- list()
true_negatives_ids <- list()
false_positives1_ids <- list()
false_positives2_ids <- list()
false_positives <- list()
false_negatives <- list()
count1 <- 1
count2 <- 1

## Iterating through the entire length of tool results and id-pool gives the same impression as usign "intersect" and "setdiff" set-operations, thereby achieving the common objective; just for flavor here.

 for (i in 1:length(seq2pathway_results_shredded$GSM2058093$GOID))
     {
       for (j in 1:length(prostate_cancer_id_pool))
         {
           if (seq2pathway_results_shredded$GSM2058093$GOID[i] == prostate_cancer_id_pool[j] && seq2pathway_results_shredded$GSM2058093$Fisher_Pvalue[i] <= 0.05)
             {
               true_positives[[count1]]<- prostate_cancer_id_pool[j]
               count1 <- count1 + 1
           }
           if (seq2pathway_results_shredded$GSM2058093$GOID[i] == prostate_cancer_id_pool[j] && seq2pathway_results_shredded$GSM2058093$Fisher_Pvalue[i] > 0.05)
             {
               false_negatives[[count2]]<- prostate_cancer_id_pool[j]
               count2 <- count2 + 1
           }
      }
  }


## Tool results' subsets on the basis of statistical significance.
greater_than_0.05 <- seq2pathway_results_shredded$GSM2058093[which(seq2pathway_results_shredded$GSM2058093$Fisher_Pvalue > 0.05),]
less_than_0.05 <- seq2pathway_results_shredded$GSM2058093[which(seq2pathway_results_shredded$GSM2058093$Fisher_Pvalue <= 0.05),]
true_negatives_ids <- setdiff(greater_than_0.05$GOID, prostate_cancer_id_pool) ## All ids that are there in the tool result with p > 0.05 and absent in the disease pool.

false_positives1_ids <- intersect(prostate_cancer_id_pool,greater_than_0.05$GOID)   
false_positives2_ids <- setdiff(less_than_0.05$GOID,prostate_cancer_id_pool)
      
false_positives <- c(false_positives1_ids,false_positives2_ids)        

## Results

cat("True positives:",length(true_positives))
cat("\nTrue negatives:",length(true_negatives_ids))
cat("\nFalse negatives:",length(false_negatives))
cat("\nFalse positives:",length(false_positives))
precision <- length(true_positives)/(length(true_positives)+length(false_positives))
cat("\nPrecision(in percentage):", precision*100)
sensitivity <- length(true_positives)/(length(true_positives)+length(false_negatives))
cat("\nSensitivity(in percentage):", sensitivity*100)
specificity <- length(true_negatives_ids)/(length(true_negatives_ids)+length(false_positives))
cat("\nSpecificity(in percentage):", specificity*100)

```



```{r Classical Sensitivity, Specificity, Precision | Enrichr}

true_positives <- list()
true_negatives_ids <- list()
false_positives1_ids <- list()
false_positives2_ids <- list()
false_positives <- list()
false_negatives <- list()
count1 <- 1
count2 <- 1

## Iterating through the entire length of tool results and id-pool gives the same impression as usign "intersect" and "setdiff" set-operations, thereby achieving the common objective; just for flavor here.

 for (i in 1:length(enrichr_results_shredded$GSM2058093$Term))
     {
       for (j in 1:length(prostate_cancer_id_pool))
         {
           if (enrichr_results_shredded$GSM2058093$Term[i] == prostate_cancer_id_pool[j] && enrichr_results_shredded$GSM2058093$P.value[i] <= 0.05)
             {
               true_positives[[count1]]<- prostate_cancer_id_pool[j]
               count1 <- count1 + 1
           }
           if (enrichr_results_shredded$GSM2058093$Term[i] == prostate_cancer_id_pool[j] && enrichr_results_shredded$GSM2058093$P.value[i] > 0.05)
             {
               false_negatives[[count2]]<- prostate_cancer_id_pool[j]
               count2 <- count2 + 1
           }
      }
  }


## Tool results' subsets on the basis of statistical significance.
greater_than_0.05 <- enrichr_results_shredded$GSM2058093[which(enrichr_results_shredded$GSM2058093$P.value > 0.05),]
less_than_0.05 <- enrichr_results_shredded$GSM2058093[which(enrichr_results_shredded$GSM2058093$P.value <= 0.05),]
true_negatives_ids <- setdiff(greater_than_0.05$Term, prostate_cancer_id_pool) ## All ids that are there in the tool result with p > 0.05 and absent in the disease pool.

false_positives1_ids <- intersect(prostate_cancer_id_pool,greater_than_0.05$Term)   
false_positives2_ids <- setdiff(less_than_0.05$Term,prostate_cancer_id_pool)
      
false_positives <- c(false_positives1_ids,false_positives2_ids)        

## Results

cat("True positives:",length(true_positives))
cat("\nTrue negatives:",length(true_negatives_ids))
cat("\nFalse negatives:",length(false_negatives))
cat("\nFalse positives:",length(false_positives))
precision <- length(true_positives)/(length(true_positives)+length(false_positives))
cat("\nPrecision(in percentage):", precision*100)
sensitivity <- length(true_positives)/(length(true_positives)+length(false_negatives))
cat("\nSensitivity(in percentage):", sensitivity*100)
specificity <- length(true_negatives_ids)/(length(true_negatives_ids)+length(false_positives))
cat("\nSpecificity(in percentage):", specificity*100)

```

